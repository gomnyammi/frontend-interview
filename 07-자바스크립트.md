## 자바스크립트
### :book: 자바스크립트가 뭐죠?
JavaScript (JS)는 가벼운, 인터프리터 혹은 just-in-time 컴파일 프로그래밍 언어로, 일급 함수를 지원합니다. 웹 페이지를 위한 스크립트 언어로 잘 알려져 있지만, Node.js, Apache CouchDB, Adobe Acrobat처럼 많은 비 브라우저 환경에서도 사용하고 있습니다. JavaScript는 프로토타입 기반, 다중 패러다임, 단일 스레드, 동적 언어로, 객체지향형, 명령형, 선언형(함수형 프로그래밍 등) 스타일을 지원합니다.

### :book: 메소드 체이닝이란 무엇이며, 이것의 장단점은 무엇인가?
### :book: 메모라이제이션이란?
### :book: 이벤트 위임에 대해 설명하세요.
### :book: this가 JavaScript에서 어떻게 작동하는지 설명하세요.
### :book: 프로토타입 상속이 어떻게 작동하는지 설명하세요.
### :book: AMD vs CommonJS에 대해 어떻게 생각하나요?
### :book: 다음이 IIFE로 작동하지 않는 이유를 설명하세요: `function foo(){ }();`를 IIFE로 만들기 위해서는 무엇을 바꿔야하나요?
### :book: null, undefined, undeclared의 차이점은 무엇인가요? 어떻게 이 상태들에 대한 확인을 할 것인가요?
### :book: 클로저는 무엇이며, 어떻게/왜 사용하나요?
### :book: 커링이 무엇이고 어디에 사용하나요?
### :book: .forEach 루프와 .map() 루프 사이의 주요 차이점을 설명할 수 있나요? 왜 둘 중 하나를 선택할 것인가요?
### :book: 익명 함수의 일반적인 사용 사례는 무엇인가요?
### :book: 코드를 어떻게 구성하나요? (모듈 패턴, 고전적인 상속?)
### :book: 호스트 객체와 내장 객체의 차이점은 무엇인가요?
### :book: `function Person(){}`, `var person = Person()`, `var person = new Person()`의 차이점은 무엇인가요?
### :book: .call과 .apply의 차이점은 무엇인가요?
### :book: Function.prototype.bind에 대해 설명하세요.
### :book: 언제 document.write()를 사용하나요?
### :book: 기능 검출(Feature detection), 기능 추론(Feature inference), UA String의 차이점은 무엇인가요?
### :book: Ajax에 대해 가능한 한 자세히 설명하세요.
### :book: Ajax를 사용하는 것의 장단점은 무엇인가요?
### :book: JSON가 어떻게 동작하는지(그리고 Ajax와 어떻게 다른지)를 설명하세요.
### :book: JavaScript 템플릿을 사용한 적이 있나요? 사용해봤다면, 어떤 라이브러리를 사용했나요?
### :book: 호이스팅에 대해 설명하세요.
### :book: event bubbling에 대해 설명하세요.
### :book: "attribute"와 "property"의 차이점은 무엇인가요?
### :book: 내장 JavaScript 객체를 확장하는 것이 좋은 생각이 아닌 이유는 무엇인가요?
### :book: document load 이벤트와 document DOMContentLoaded 이벤트의 차이점은 무엇인가요?
### :book: ==와 ===의 차이점은 무엇인가요?
### :book: JavaScript와 관련하여 same-origin 정책을 설명하세요.
### :book: 다음이 작동하게 만들어보세요.
### :book: "use strict"; 이 무엇인가요? 사용시 장단점이 무엇인가요?
### :book: 100까지 증가하면서 3의 배수에는 fizz를 출력하고, 5의 배수에는 buzz를 출력하고, 3과 5의 배수에는 fizzbuzz를 출력하는 for loop를 만드세요.
### :book: 전역 scope를 사용했을 때 장단점에 관해 설명해주세요.
### :book: 일반적으로 웹 사이트의 전역 스코프를 그대로 두고 건드리지 않는 것이 좋은 이유는 무엇인가요?
### :book: 왜 load 이벤트와 같은 것을 사용하나요? 이 이벤트에는 단점이 있나요? 다른 대안을 알고 있나요? 알고 있다면 왜 그것을 사용할 건가요?
### :book: single page app이 무엇인지 설명하고 SEO-friendly하게 만드는 방법을 설명하세요.
### :book: Promises와 그 Polyfill에 대한 당신의 경험은 어느 정도인가요?
### :book: Callback 대신에 Promise를 사용할 때의 장점과 단점은 무엇인가요?
### :book: JavaScript로 컴파일되는 언어로 JavaScript 코드를 작성하는 경우의 장단점은 무엇인가요?
### :book: JavaScript 코드를 디버깅하기 위해 어떤 도구와 기술을 사용하나요?
### :book: 오브젝트 속성이나 배열 항목을 반복할 때 사용하는 언어 구문은 무엇인가요?
### :book: mutable 객체와 immutable 객체 사이의 차이점을 설명하세요.
### :book: mutable object와 immutable object에 관해 설명해주세요.
### :book: JavaScript에서 immutable 객체의 예를 들어보세요.
### :book: immutability의 장/단점은 무엇인가요?
### :book: 자신의 코드에서 불변성(immutability를) 어떻게 달성할 수 있나요?
### :book: 동기, 비동기 함수의 차이점을 설명하세요.
### :book: 이벤트 루프란 무엇인가요? 콜 스택과 태스크 큐의 차이점은 무엇인가요?
### :book: function foo() {}와 var foo = function() {} 사이에서 foo 사용의 차이에 대해 설명하세요.
### :book: let, var, const를 사용하여 생성된 변수들의 차이점은 무엇인가요?
### :book: ES6 클래스와 ES5 함수 생성자의 차이점은 무엇인가요?
### :book: 새 화살표 => 함수 문법에 대한 사용 예시를 들 수 있나요? 이 새로운 문법은 다른 함수와 어떻게 다른가요?
> 화살표 함수 도입에 영향을 준 두 요소: 보다 짧아진 함수 및 바인딩하지 않은 this.

1. this나 super에 대한 바인딩이 없고, methods 로 사용될 수 없습니다.
2. new.target키워드가 없습니다.
3. 일반적으로 스코프를 지정할 때 사용하는 call, apply, bind methods를 이용할 수 없습니다.
4. 생성자(Constructor)로 사용할 수 없습니다.
5. yield를 화살표 함수 내부에서 사용할 수 없습니다.

화살표 함수는 자신의 this가 없습니다.  대신 화살표 함수를 둘러싸는 렉시컬 범위(lexical scope)의 this가 사용됩니다; 화살표 함수는 일반 변수 조회 규칙(normal variable lookup rules)을 따릅니다. 때문에 현재 범위에서 존재하지 않는 this를 찾을 때, 화살표 함수는 바로 바깥 범위에서 this를 찾는것으로 검색을 끝내게 됩니다.

### :book: 생성자의 메서드에 화살표 문법을 사용하면 어떤 이점이 있나요?
this 바인딩 이점이 있습니다. 위와 같습니다.

### :book: 고차 함수(higher-order function)의 정의는 무엇인가요?
### :book: 객체나 배열에 대한 디스트럭쳐링 예시를 들 수 있나요?
### :book: ES6 템플릿 리터럴은 문자열을 생성하는데 많은 유연성을 제공합니다. 이에 대한 예를 들 수 있나요?
### :book: curry 함수의 예를 들어 줄 수 있나요? 그리고 이 문법은 어떤 이점을 가지고 있나요?
### :book: spread 문법을 사용할 때의 이점은 무엇이며 rest 문법과 다른 점은 무엇인가요?
### :book: 파일 간에 코드를 공유하려면 어떻게 해야하나요?
### :book: 정적 클래스 멤버를 만드는 이유는 무엇인가요?
### :book: 자바스크립트 this란?
### :book: 화살표 함수, call, bind, apply에 대해
### :book: 자바스크립트 이벤트 관리 방법? 보통 어떤 식으로 이벤트를 설계해야 하는지?
### :book: 이벤트 캡처링 & 버블링
### :book: 이벤트 등록 & 해제
### :book: 이벤트 위임 방식 등
### :book: 자바스크립트 비동기 처리에 대한 설명
### :book: 콜백, 프로미스, async await
### :book: 비동기 처리의 특성 및 에러 처리 방법?
### :book: Virtual DOM이 뭔지 아시는지? 썼을 때의 장점?
### :book: REST API로 받은 객체와 배열은 보통 어떤 자바스크립트 API나 로직을 이용해서 화면에 맞게 가공을 하는지?
### :book: map, filter, reduce API 사용 경험과 각각 설명
### :book: 함수형 프로그래밍이란?
### :book: 자바스크립트 클로저란?
### :book: 자바스크립트 프로토타입이란?
### :book: AJAX란 무엇인가
### :book: Promise란 무엇이며 코드가 어떻게 구성되어있는가
### :book: Promise와 Callback의 차이점은 무엇이며 각각의 장단점에 대해 설명해달라
### :book: async/await와 Promise의 차이는 무엇인가요
### :book: 자바스크립트의 Number Type은 다른 언어들과 차이점이 무엇인가, 왜 하나만 존재하나.
### :book: 자바스크립트의 원시 타입은 몇가지인가? 종류는?
### :book: 실행 컨텍스트(Execution Context)에 대해 설명해달라
### :book: 자바스크립트의 호이스팅(Hoisting)은 어떻게 이루어져 있는가
### :book: 클로저(Closure)란 무엇이며, 왜 이러한 패턴을 사용하는가
### :book: 가비지컬렉터의 역할은? 어떻게 동작?
### :book: 자바스크립트의 배열이 실제 자료구조 배열이 아닌데 그 이유는?
### :book: 이벤트 루프에 대해서 설명, 동시성 모델에 대해서 설명
### :book: 프로토타입이란?
### :book: 자바스크립트에서 This는 몇가지로 추론 될수 있는가, 아는대로 말해달라
### :book: 일반함수의 this와 화살표 함수의 this는 어떻게 다른가?
### :book: Call, Apply, Bind 함수에 대해 설명해달라
### :book: use strict모드에서의 this?
### :book: 크롬 정도의 브라우저를 제외하곤 ES6 스펙에 대한 지원이 완벽하지 않다. 해결방법은 무엇인가
트랜스파일러를 적극 도입합니다. 바벨로 문법을 변환하고, 폴리필로 부족한 함수를 내포시킵니다.
## :book: ES6에서 추가 된 스펙에 대해 아는 대로 설명해주세요. [es6 추가](https://jsdev.kr/t/es6/2944)
1. 화살표 함수가 존재합니다. this 바인딩의 불편함이 해소되었고 순수함수의 구현이 쉬워졌습니다.
2. 객체 리터럴로 객체를 생성하는 것이 간단해졌습니다. 동일한 식별자명으로 프로퍼티를 선언할 경우 value를 생략하는 단축 표기법이 도입되었고, 메서드를 간소화하여 추가할 수 있습니다. 그에 따라 객체 리터럴 및 클래스 선언이 더 밀접되어져, 객체기반 설계가 더 편리해졌습니다.
3. 템플릿 문자열이 추가되어 문자열로 식별자와 연산을 표현하기 쉬워졌습니다. 인젝션 공격 방어 혹은 문자열로 부터 상위 데이터 구조체 재조립 등을 위해 string 생성을 커스터마이징이 가능하게끔 해줍니다.
4. 구조분해할당, 디스턱쳐링이 추가되면서 객체와 배열에서 필요한 값을 선택하는 것이 편해졌습니다. Destructuring는 배열과 객체에 패턴 매칭을 통한 데이터 바인딩을 제공합니다. Destructuring는 할당 실패에 유연하며, 실패 시 undefined 값이 자동할당 됩니다. 또한 foo["bar"]와 같이 객체의 속성 값도 자동으로 검색하여 바인딩해줍니다.
5. Class라는 문법적 설탕이 추가되었습니다. ES6 클래스는 포로토타입 기반 객체지향 패턴을 더 쉽게 사용할 수 있는 대체재입니다. 클래스 패턴 생성을 더 쉽고 단순하게 생성할 수 있어서 사용하기도 편하고 상호운용성도 증가됩니다.
6. Default + Rest + Spread : 파라미터에 기본 값을 설정할 수 있으며, 가변 인자를 사용하여 배열로 치환 가능하고 배열의 인자를 나누어 주입합니다.
7. 새로운 스코프를 갖는 let, const를 도입하여 var의 문제점을 해소합니다.
8. 이터레이터를 추가하여 for ... of문을 사용할 수 있게 해줍니다. for ...in과는 다르게 동작합니다.
9. Generators : Generators는 function*와 yield 키워드를 이용하여 iterator 선언을 단순하게 작성할 수 있게 도와줍니다. function*로 선언한 함수는 Generator 객체를 반환합니다. Generators는 iterator의 하위 타입이며 next와 throw 메서드를 가지고 있습니다. 이 메서드들로 인해 yield 키워드로 반환된 값은 다시 generator에 주입거나 예외처리를 할 수 있게 되었습니다. 해당 키워드는 비동기 프로그래밍의 ‘await’ 같은 기능이 가능하게끔 기반이 되었습니다. 
10. Modules : 언어 차원에서 컴포넌트 정의를 위한 모듈을 지원합니다. 유명한 JavaScript 모듈 로더들(AMD, CommonJS)의 패턴을 적용시켰습니다. 런타임 동작은 호스트에 정의된 기본 로더에 의해 정의됩니다. 묵시적 비동기 형태로 요구되는 모듈들이 정상적으로 로드되기 전까지 코드가 실행되지 않습니다.
11. Module Loaders : 기본으로 사용할 모듈 로더를 설정할 수 있으며, 로더를 새로 생성하여 격리되거나 제한된 맥락에서 코드를 로드할 수 있습니다.
    - 동적 로딍(Dynamic loading)
    - 상태 격리(State isolation)
    - 전역 네임스페이스 격리(Global namespace isolation)
    - 컴파일 훅(Compilation hooks)
    - 중첩 가상화(Nested virtualization)
12. Map + Set + WeakMap + WeakSet : 일반 알고리즘을 위한 효율적인 데이터 구조를 제공합니다. WeakMap과 WeakSet는 메모리 누수로 부터 자유롭게 해줍니다. 이들 내 저장된 객체에 다른 참조가 없는 경우, garbage collection 될 수 있습니다.
13. 프록시(Proxy)를 사용하면 호스트 객체에 다양한 기능을 추가하여 객체를 생성할 수 있습니다. interception, 객체 추상화, 로깅/수집, 값 검증 등에 사용될 수 있습니다.
14. 심볼(Symbol)은 객체 상태의 접근 제어를 가능하게 합니다. Symbol은 새로운 원시 타입으로 이름 충돌의 위험 없이 속성(property)의 키(key)로 사용할 수 있습니다. 옵션 파라미터인 description는 디버깅 용도로 사용되며 식별 용도는 아닙니다. Symbol은 고유(unique)하며, Object.getOwnPropertySymbols와 같은 reflection 기능들로 접근할 수 있기 때문에 private 하진 않습니다(for in나 Object.keys()로는 접근 불가).
15. Subclassable Built-ins : ES6에서 Array, Date, DOM Element 같이 내장 객체들은 상속이 가능합니다. 객체 생성 시 호출되는 Ctor 함수는 다음의 2단계를 가집니다.(둘다 가상적으로 실행)
    - 객체 할당을 위해 Ctor[@@create] 호출하여
    - 새로운 인스턴스의 생성자를 호출해 초기화 진행
    - 아시다시피 @@create 심볼은 Symbol.create를 통해 만들어졌습니다.
16. core Math 라이브러리, Array 생성 helper, String helper, 복사를 위한 Object.assign 등 많은 라이브러리들이 추가되었습니다.
    ```js
    Number.EPSILON
    Number.isInteger(Infinity) // false
    Number.isNaN("NaN") // false

    Math.acosh(3) // 1.762747174039086
    Math.hypot(3, 4) // 5
    Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2

    "abcde".includes("cd") // true
    "abc".repeat(3) // "abcabcabc"

    Array.from(document.querySelectorAll('*')) // Returns a real Array
    Array.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior
    [0, 0, 0].fill(7, 1) // [0,7,7]
    [1, 2, 3].find(x => x == 3) // 3
    [1, 2, 3].findIndex(x => x == 2) // 1
    [1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2]
    ["a", "b", "c"].entries() // iterator [0, "a"], [1,"b"], [2,"c"]
    ["a", "b", "c"].keys() // iterator 0, 1, 2
    ["a", "b", "c"].values() // iterator "a", "b", "c"

    Object.assign(Point, { origin: new Point(0,0) })
    ```
17. Promises : Promise는 비동기 프로그래밍을 위한 라이브러리입니다. Promise는 미래에 생성되는 값을 나타내는 일급 객체입니다. Promise는 현존하는 많은 JavaScript 라이브러리에 사용되고 있습니다.
18. Reflect API : Reflection API는 런타임 시 객체에 대해 작업을 수행할 수 있습니다. 프록시 트랩(proxy traps)와 같은 메타 함수들을 가지고 있습니다. Reflection은 프록시를 구현하는데 유용합니다.
19. Tail Calls : 마지막에 호출되는 함수가 호출 스택이 초과되게 하지 않습니다. 재귀 알고리즘을 매우 큰 입력 값에서도 안전하게 만듭니다.

## :book: var 와 let, const의 차이점은 무엇인가 (function scope와 block scope의 개념에서)
### :book: Class 는 무엇이고, Prototype, fucntion의 ES5 스펙만으로 Class를 구현할수 있는가
### :book: 이벤트 위임이란?
### :book: 가상돔 (virtual DOM)
### :book: 가상돔(Virtual DOM) 개념은 무엇이며, DOM과의 차이점 가상돔의 개념이 사용되게된 배경은 무엇인가
### :book: DOM을 건드리는 방식과 아닌 방식들의 차이
### :book: Call by value & call by ref
### :book: null vs undefined ?
### :book: DOM을 직접 조작하는 D3.js 같은 라이브러리와의 결합시에 예상되는 문제점이 있는가
[](http://52.78.22.201/tutorials/weplanet/how-to-use-d3/)

React와 D3.js를 함께 사용할 때의 문제점은 두 라이브러리 모두 DOM의 렌더링을 장악/통제하려 한다는 것이다. D3.js 는 선택과 하위 항목의 첨부 + 업데이트를 통해 DOM을 수정하고, React는 요소의 성질이나 상태가 변할 때마다 렌더 함수의 렌더링 요소를 통해 DOM을 수정한다. 이 접근법들을 보고 그 방법들을 결합시킬 방법도 살펴 보자.

1. React를 사용하여 렌더링하기
React는 JSX에서 직접 svg 요소 렌더링을 처리할 수 있어서 우리는 D3의 렌더링 능력을 전혀 이용할 필요가 없다. 차라리 D3를 데이터의 쉬운 로딩, 활용, 포맷팅을 가능하게 하는 d3-scale, d3-request, d3-path 등과 같은 D3 도움 함수로 사용할 것이다. 그 후에 우리는 렌더링을 처리하는 React 컴포넌트를 만들 수 있다.

   - 장점 : 더 나은 차트 구조, 더 읽기 쉬움
   - 단점 : DOM을 직접 수정할 수 있는 d3.transition과 기타 D3 함수를 사용하지 않음, 요소의 소품과 재 렌더링에 애니메이션 효과를 주는 것이 D3의 애니메이션을 사용하는 것보다 느림

2. D3사용하여 렌더링하기
또 다른 옵션은 React의 렌더링을 다음과 같이 사용하지 못하게 한다. shouldComponentUpdate() { return false }

그리고 D3가 svg elements를 만들도록 하는 것이다. 우리는 단일 svg 컨테이너를 렌더링하는 하나의 React 컴포넌트를 만들고, constructor (props)와 componentWillReceiveProps (nextProps) 함수에서 주어진 데이터 변화에 따라 D3가 DOM을 만드는 것을 처리하도록 한다. 애니메이션은 주로 외부 이벤트에 의해 작동된다. 예를 들어, 버튼 클릭은 React 컴포넌트 트리를 통해 전파되고, D3 요소의 componentWillReceiveProps를 불러내고, 그것은 D3의 업데이트 선택을 사용하여 트렌지션 효과를 작동시킨다.

    - 장점 : d3.transition 애니메이션처럼 D3의 모든 함수를 사용할 수 있음
    - 단점 : 하나의 컴포넌트에 전체 차트를 넣음으로써 구조화가 약함, 개별 파트간 Tight-coupling 발생, 읽기 힘듦

3. 하이브리드 접근법
나는 하이브리드 접근법을 선호한다. React 컴포넌트를 사용하면서 얻게되는 구조와 가독성을 선호하지만, DOM 요소에서 직접 전환 효과를 사용하는 것 또한 좋아한다. 그래서 필자는 두 가지 접근법을 결합한다. React가 대부분의 모든 고정 요소 (컨테이너, 타이틀, 축, 범례) 를 렌더링 하도록하고 D3가 애니메이션화 해야하는 모든 것들을 (데이터 시리즈) 렌더링 하도록 한다. 예를 들어, 이 방법의 실행을 내 Bubble Chart on GitHub 에서 볼 수 있다 ( 또는 여기에서 실행할 수 있다.) 버블 요소를 제외한 모든 요소는 고정 요소이며, 변화하지 않으므로 필자는 이 요소들을 React 내에서 렌더링한다. 버블 요소는 D3에서 force layout을 사용하여 원형들을 렌더링하고 애니메이션화한다. 그렇게 하면 App.js 는 다음과 같이 보인다.

좋은 독립적 차트 구조
적절한 곳(애니메이션)에 D3를 직접적으로 사용할 수 있음


### :book: SPA에서 SEO에 유리하도록 만들기 위한 방법에 대해 설명해주세요.
### :book: JavaScript의 작동방식의 장단점에 관해 설명해주세요.
### :book: JavaScript를 디버깅할 때 사용하는 도구가 있으면 설명해주세요.
크롬 디버거 콘솔과 IE 개발자 도구를 주로 사용합니다.

### :book: 성능관련 이슈들을 발견하기 위해서 사용하는 방법은 무엇인가요?
[toastui](https://ui.toast.com/fe-guide/ko_PERFORMANCE)
[자바스크립트 성능 향상 방법](https://junwoo45.github.io/2020-01-29-javascript_performance/)
[자바스크립트 함수의 성능 측정하기](https://yceffort.kr/2020/12/measuring-performance-of-javascript-functions)
[마이리얼트립1](https://medium.com/myrealtrip-product/fe-website-perf-part1-6ae5b10e3433)
[마이리얼트립2](https://medium.com/myrealtrip-product/fe-website-perf-part2-e0c7462ef822)
[최종정리 끝](https://coffeeandcakeandnewjeong.tistory.com/34)

### :book: 웹사이트 scrolling 성능을 향상시키기 위한 몇가지 방법에 대해 설명해보세요.
1. 스로틀
2. 디바운스
3. html 태그에 적용되면 전체 페이지 배경 이미지가 좋아지지만 앞서 언급한 것처럼 스크롤이 매우 느립니다. 정확히 말하자면 초당 6프레임에 불과합니다.
   - 다음의 스타일을 html 태그에 적용하면 프레임률이 600% 향상되는 것을 볼 수 있습니다.
      ```css
      html {
        -webkit-transform: translate3d(0,0,0);
      }
      ```
   - 또한, 스크롤에 아래 옵션을 넣어서 iOS 에서 스크롤 속도를 높일 수 있습니다.
      ```css
      html {
        -webkit-overflow-scrolling: touch;
      }
      ```
   - 단 translate3d or translateZ는 CPU가 아닌 GPU에 엘리먼트를 합성하여 작동하는데, 데스크탑에서는 상관 없으나 처리 능력이 부족한 모바일의 경우 대량의 데이터가 이동 되면 성능을 많이 저하시킵니다.



### :book: 브라우저의 layout, painting, compositing에 대해 설명해보세요. [구글 설명](https://developers.google.com/web/fundamentals/performance/rendering?hl=ko)
https://www.slideshare.net/deview/d2-1