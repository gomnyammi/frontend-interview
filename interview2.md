# 기초
## 간단한 자기소개 부탁드립니다.
안녕하세요, 미래를 성실함으로 코딩하는 프론트엔드 개발 지원자 소인성입니다.
군 간부 출신이자 15년만의 1차 진급자였던 저는 개발자에게 필요한 서비스에 대한 책임감, 협업 역량 및 도전을 통한 성장력을 갖추었습니다.
이러한 역량을 바탕으로 카카오페이의 누구나 마음 놓을 수 있는 서비스를 발전시켜 나가겠습니다.

<br>

## 지원동기
첫 이유는 처음 카카오페이를 접했을 때 감동이 있었기 때문입니다. 군 훈련 간 은행 업무를 처리해야 하는 경우 많은 불편함이 있었는데, 카카오페이는 비밀번호 인증 하나로 깔끔히 처리되었습니다. 이게 인상 깊었던 이유는 비단 편안함 뿐만이 아니었습니다. 기존의 금융 시스템 틀을 깬 것이었죠. 이미 그때부터 카카오페이에서 일하고 싶다는 생각을 했습니다.

관념을 깨고 추구하는 바를 이루는 것. 카카오페이는 그 행보가 저의 가치관과 일치했으며, 개발자로서도 많은 곳을 경험하고 시도할 수 있다는 생각이 있었습니다.

<br>

## 프론트엔드 개발자를 선택한 이유
프론트엔드라는 분야의 무궁무진한 발전 가능성이 매력적이었습니다. 빅데이터의 시대, AI, 메타버스... 많은 기술들이 존재하지만, 이 모든 것은 브라우저가 있었기 때문이라고 생각합니다. 네트워크 통신은 저희 세대가 끝날 때까지 존재할 것이며, 하루도 빠짐없이 성장할 것입니다. 그 중 가장 활발히 일어나는 것이 프론트엔드의 기술 변화였습니다. 그래서 선택했습니다.

<br>

## 프론트엔드 개발자를 선택하면서 자신만의 강점은?
성장력이라고 말하고 싶었지만 그보다 더한 강점은 개발자 입장에서가 아닌, 사용자 입장에서 생각하는 것입니다. 기능이 동작된다고 완료된 게 아니니까요. 오류가 나지 않는 것은 당연한 것이고, 생각하지 못한 것, 요구사항이나 갭 분석에서 등장하지 않았던 문제나 불편함도 잡아낼 수 있어야 했습니다. 저는 이런 면에서 객관적으로 생각하는 것이 저의 강점이라고 생각합니다.

<br>

## 단점, 이것만은 고쳐야한다는 것
옆그레이드라고 표현하는데, 문제에 봉착하면 이를 해결하다가도 깊게 들어가는 경향이 있습니다. 특히 혼자 업무를 하거나 공부를 하게 되면 그저 점검만 하면 되는 것을 점검을 위한 기능을 추가하고 있거나 말이죠. 협업을 하면서 이런 부분이 많이 불식되었고, 객관화를 하기 위해 많은 단계를 만들어 놓았으며 매몰되는 느낌이 들면 이 단계를 밟아가면서 검증하고 있습니다.

<br>

## 리더형인지 팔로워 형인지?
리더형입니다. 선두에 나서서 이끄는 것을 좋아하지 않지만, 다른 사람의 의견을 귀기울여 들을 줄 압니다. 조직이 리더만으로 이루어지지 않았다는 것도 압니다. 따라서 조직원들의 의사결정을 존중하며 논리적 이성과 감정적 감성을 적절히 혼합해 무엇을 어떻게 해야할지 결정하곤 합니다. 대부분 최후의 결정을 하지 못하고 있을 때 이를 바탕으로 선택하는 것이 제가 리더형으로써 하는 역할이죠.

<br>

## 다른 회사도 지원한 곳이 있는가
없습니다. 공부를 해서 카카오페이에 가고 싶다는 생각을 했었기 때문이었고 지속적으로 공부하고 있었습니다.

<br>

## 두 곳 다 합격하면 어떻게 할 겁니까
카카오페이에 갈 겁니다. 그러나 카카오페이가 아닌 다른 회사 두 군데에 합격했다면, 저의 성장 가능성과 회사가 갖고 있는 비전을 비교한 뒤 선택하겠습니다.

<br>

## 실패했던 경험과 극복한 방법

<br>

## 단체활동 중 갈등을 겪었던 경험, 이를 해결한 방법
저의 실패 경험은 혼자 선택함에 있어 비롯됩니다. 가장 큰 실패의 경험은 군대였죠. 제 선에서 처리하면 모두가 행복할 줄 알았습니다만 비난의 화살이 오더군요. 이유를 알고 보니 주제 넘게 참견하여 일을 크게 키웠다는 것입니다. 

<br>

## 다른 직무에 배치된다면?
인생은 길고, 하나의 직무만 맡는다는 생각은 하지 않았습니다. 기초부터 찾아보고 분석하여 이해를 하는데 시간을 쏟을 것입니다. 업무 이해도를 높이면 업무 능력이 향상되니까요. 그러나 나아가고자 하는 분야가 아니거나 성장할 생각 없이 흘러가는 형태라면 진지하게 고려할 것입니다.

<br>

## 지방 근무에 대해
감수하고 있습니다.

<br>

## 상사의 불합리한 지시에는 어떻게 대응할건가요?
우선 이행한 뒤, 도출되는 문제점과 이를 해결할 방안을 탐색하여 조심스레 건의드릴 것입니다. 업무적인 부분이 아니라 사적인 부분이라도 명확하게 말씀드리고요.

<br>

## 당신을 꼭 뽑아야 하는 이유는 무엇인가요?
가장 큰 것은 성장곡선이 가파르다는 것이며, 그럼에도 불구하고 모두와 함께 성장하려고 하는 것입니다. 저는 이끌 줄 알고, 제가 어려워했던 경험이나 성장했던 방향과 길을 알려주거나 제안할 수 있습니다.

<br>

## 하고 싶은 질문
내가 개발해서 서비스를 할 때, 남들이 발견하지 못한 에러를 발견할 때는 어떻게 하나요? 사내 스터디가 존재하나요? 사내 해커톤 같은 행사가 있을까요?

<br>

## 마지막으로 하고 싶은 이야기
사전과제가 저에게 정말 많은 공부가 되었습니다. 그 기점으로 프론트엔드 개발자로써의 역량이 향상된 것을 느낍니다. 아, 성장하고 있구나를 본격적으로 느껴 많은 보람을 느꼈어요. 감사합니다.

<br>

## 퇴사 후 무엇을 했나요?
우선 무엇을 모르는지 정리했습니다. 어떻게 공부해야하는지, 이 부분을 해결하기 위해서는 어떻게 해야 하는지를요. 제 기준에서 정리가 끝나고 멘토링을 통해 점검받았습니다. 그 후 코딩테스트를 준비한다며 인강도 듣고... 그러다가 직접 스터디를 운영하기 시작했습니다. 효과는 놀라웠죠. 제가 방향성을 잡아야 스터디를 이끌게 되니 무엇을 해야하는지 스스로 결정하고 있었습니다.

생전 처음보는 구문을 계속해서 써보고, 알려주고, 구현도 해보고 하지 지난날의 저보다 너무나 많은 성장을 한 걸 느꼈습니다. 깃헙에 이러한 내용을 정리하면서 성장의 발판을 착실히 쌓아올렸죠.

<br>

## 프런트엔드 개발은 지속적으로 학습해야 하는 분야인데 어떤식으로 학습을 하고 있나요?
새로운 기술 블로그 글을 확인하고, Github를 확인합니다. 생소한 개념보다는 제가 필요하다고 생각되는 부분, 약하다고 생각되는 부분을 중점적으로 적어두고 이를 탐색합니다. 효과적으로 구현할 수 있다면 이를 직접 해보고, 그게 아니라면 이론으로써 갖고 있다가 스터디원들에게 공유하거나 주변 개발자들과 공유하여 브레인 스토밍을 꾀합니다.

<br>

## 다른 직무의 동료들과 어떤 식으로 커뮤니케이션 하나요?
그들과 대화하기 전에 내가 무엇을 알고 있는지 정리합니다. 내 생각과 의사를 어떻게 전달하면 효율적으로 이해할 수 있을지 고민하고, 단어와 문장을 선택함에 신경을 씁니다. 최대한 친숙한 환경에서 대화를 이끌려고 하죠. 또한 의사를 묻는 형태로 말을 맺습니다. 그저 자기가 할말만 하는게 아니라 의사를 물어보기 위한 질문을 자주 합니다.

<br>

## 여태까지 소속되었던 팀 내부적으로 혹은 회사 외부적으로 지식 공유나 지식 전파 같은 활동들을 해본 적이 있는지?
소속 팀, 소속 프로젝트, 특정 개발자 그룹 등에서 주도적으로 진행해 왔습니다. 교육을 도맡아 했고 새로운 내용이나 좀 더 효율적이고 이로운 지식들을 전파하는데 힘 썼습니다.

<br>

## 공부는 어떻게 하나요?
무엇을 공부할 것인지 정합니다. 그 항목이 정해졌으면 서적을 찾습니다. 혹은 인터넷 강의나, 문서를요. 그 다음 목차를 정리합니다. 내가 원하는 것을 도달하기 위해 어떤 스탭을 가져가야할까를 고민하고 이를 제가 가지는 형태로 맞춥니다. 개념과 이해가 필요한 부분, 응용과 직접 해보기 등으로요. 그러한 일련의 과정을 글로써 남깁니다.

<br>

## 이직하려는 회사의 직무에서 기대하는 부분과 기여할 수 있는 부분?
사용자 경험성, 튼튼한 애플리케이션의 개발, 다른 개발자들과의 기술적인 토론입니다. 

<br>

## 최근에 읽은 도서
마이클 샌델의 공정하다는 착각, 재러드 다이아몬드의 총 균 쇠입니다.

<br>

# 경력 기반
## chart.js를 사용하면서 좋았던 점? 나빴던 점?
패키지에 이식시키기 좋았습니다. canvas 태그에 들어가므로 이 요소만 제어하면 되었기 때문입니다. 

좋은 점은 데이터만 전달하여 자바스크립트로 파싱하면 웹 브라우저가 알아서 그려주니 크게 신경쓰지 않아도 된다는 것입니다.

나쁜 점이라면 chart js가 제공하는 속성만 쉽게 쓸 수 있다는 점입니다. 고객사가 많은 요구사항을 들고 왔는데 이를 구현해야 했을 때 많은 시행착오가 있었죠.

<br>

## Vue로 개발한 UI 컴포넌트에 대해 설명해주세요.
formatted-input, locale-calendar, checked-modal, cleared-text-area, check-field가 있습니다.

<br>

## 왜 jQuery에서 Vue로 변경했나요? React는 생각하지 않았나요?
기본적으로는 템플릿 이용을 더 간단한 대안으로 제공합니다. 잘 작동하는 HTML은 Vue 템플릿으로도 잘 작동하며 여기에서 오는 장점들이 있습니다.

HTML로 작업해온 많은 개발자에게는 템플릿을 읽고 쓰는 것이 어렵지 않습니다. 선호라는 것은 다소 주관적일 수도 있겠지만 개발자의 생산성이 올라간다면 그건 객관적인 거죠.
HTML 기반 템플릿을 이용하면 기존의 어플리케이션을 Vue로 점진적으로 이전하기가 훨씬 쉽습니다.
또한 디자이너와 경험이 적은 개발자들이 코드를 분석하고 기여하기에도 훨씬 쉽습니다.(역자: 러닝 커브가 낮습니다)
Vue 템플릿을 쓸 때 Pug(이전의 Jade)같은 프리프로세서를 사용할 수도 있습니다.

싱글 파일 컴포넌트의 스타일

리액트는 러닝 커브가 너무 가파릅니다. ES6+ 구문을 이해해야 하며, 빌드 시스템에 대해서도 이해해야 했죠. 그러나 뷰는 vue 파일 하나만을 import하는 것부터 시작할 수 있었으며 JSX, ES2015 또는 빌드 시스템에 대해 알 필요가 없으므로 일반적으로 개발자가 일상적인 애플리케이션을 빌드하는 데 필요한 충분한 지식을 얻기 위해 가이드를 읽는 데 하루가 걸리지 않습니다.

<br>

## SSO 인증은 어떻게 개발했나요? Promise와 setTimeout에 대해 설명해주세요.
앱을 통한 접속은 해당 기업의 SSO 인증이 완료 되어야 했습니다. 그러나 이에 대해 구현하는 방법을 몰랐던 타 개발자가 setTimout으로 무조건 대기 후 결과를 받게 코드를 작성해놨습니다. 저는 이를 Promise로 변경하고 오류에 대한 처리까지 완료했습니다.

Promise는 특정 시점에 resolve, reject를 반환하는 객체로 fullfilment, reject, pending 세 가지 상태 중 하나일 수 있습니다. 저희는 여기에 then과 catch를 사용하여 추가적인 작업을 할 수 있습니다.

setTimeout은 자바스크립트 네이티브 객체가 아니라 Web API 중 일부로 코드를 바로 실행하지 않고 지정한 시간만큼 기다렸다가 로직을 실행합니다.

<br>

## 다양한 모바일 기기 환경을 경험한 느낌은 어땠나요?
난감했습니다. 테스트 기기가 없었고, 크롬에서 지원하는 모바일 기기도 많지 않았으며 내부망을 사용하여 디버깅하기 쉽지 않았습니다. 많은 이슈가 있었습니다. 그러나 생소한 에러를 마주하면서 이러한 이슈가 발생할 수도 있구나 라는 걸 느꼈고, 앞으로도 이에 대처할 수 있게 준비를 해야겠다 생각했습니다.

<br>

## IE 브라우저 이슈에 대해 설명해주세요.
로컬스토리지

<br>

## 양방향, 단방향 암호화에 대해 설명해주세요.
양방향 암호화는 평문을 암/복호화 할 수 있으며, 단방향 암호화는 복호화가 불가능합니다.

암호화와 복호화를 동일한 키로 진행하는 경우 대칭키(비공개 키) 암호화, 다른 키일 경우 비대칭키(공개 키) 암호화라고 합니다.

비밀번호는 SHA256을 이용한 단방향 암호화를, 주민등록번호와 세션 아이디는 RSA 알고리즘을 적용한 공개키 암호화를 적용했었습니다.

<br>

## 브라우저 저장소를 설명해주시고, 어떤 차이점이 있는지와 이걸 왜 사용했는지 알려주세요. 무슨 문제가 있었나요?
기본적으로 HTTP는 stateless로서 메모리가 없습니다. 웹 사이트는 유저와 항상 연결되어있지 않죠. 우리가 사이트에 request보내면 서버와 그때 연결됩니다. 그 이후는 연결이 끊어집니다. 살려둬야할 이유가 없죠. 그러나 로그인 상태 유지, 유저의 지역 정보등.... 기억할 필요가 생겼습니다. 가장 흔한 것으로는 auth가 있죠.

브라우저는 인증 정보를 갖고 있으며, 자동으로 모든 쿠키를 가져다 하드디스크에 저장합니다. 또한 요청을 보낼 때마다 웹사이트에서 모은 쿠키를 전송합니다. 서버는 쿠키를 확인하고 응답하죠. HTTP는 상태가 없으므로 이를 기억하기 위해 쿠키가 필요한겁니다.

쿠키에는 규칙이 있습니다. 한개의 도메인에 한정되어 있을 것. 쿠키들은 자동으로 보내집니다(서버는 원하는 만큼 쿠키를 보내고, 브라우저는 자동으로 젖아합니다). 그리고 자동으로 설정됩니다.


<br>

## SPA 개발을 했는데 어떤게 다른가요? 하이브리드 앱이란 무엇인가요?
겉으로 보기에는 앱이지만, 실제로는 웹을 기반으로 앱의 기능을 차용한 형태의 앱을 하이브리드 앱이라고 합니다. SPA 개발이라고는 했지만... 패지키가 SPA스럽게 개발을 한 것일 뿐 실제로는 MPA에 가깝습니다. 메인 프레임을 그려두고 iframe을 통해 다른 HTML을 주기적으로 불러오는 형태로 개발했습니다.

<br>

## 모듈화의 의미는 무엇인가요? 어떻게 개발했나요?
모듈은 한가지 일만 수행해야 하며, 역할이 간단하고 명료해야 합니다. 또한 다른 프로그램에서도 사용할 수 있도록 단순해야 합니다. 여러 프로그램에서 붙여서 쓸 수 있도록 독립성을 유지해야 합니다.

이로써 재사용성이 높아지며 유지보수가 쉬워집니다.

<br>

## 웹 크롤링 Batch는 무엇으로 개발했나요?
웹 크롤링 라이브러리는 Node.js의 cheerio를, Batch는 node-cron으로 작업했습니다. cheerio의 경우 jQuery 문법을 알고 있어 사용하기 간편했습니다. 반환받은 객체를 정규표현식을 통해 파싱했고 해당 데이터를 라즈베리파이 데이터베이스와 연결하여 크롤링 했습니다.

크롤링 주기는 매주 월 ~ 금 11시 30분 00초(00 30 11 * * 1-5)에 실행하게 했습니다. node-schedule이 다운로드 횟수가 많고 커뮤니티가 활발하지만 리눅스 crontab을 생각하고 찾아본 터라 node-cron을 사용하게 되었습니다. 두 라이브러리의 큰 차이점도 사실 못 찾았으므로 괜찮다고 생각했습니다.


<br>

## OCR 연동 화면 프로그램을 리팩토링했는데, 어떻게 하셨나요?
장황한 if문을 삼항 연산자, 객체를 활용하여 줄였고 순서를 조정하여 하나의 조건에 여러 항목이 필터링 되게 수정했습니다. 중복되는 내용은 함수로 분리시키고, 변수명을 통일 시켰습니다. 상태 코드도 수정 불가능한 객체로 변경하여 비교했고 중복되는 이벤트 핸들링을 위임으로 처리했습니다. 주석과 공백문자를 정리하고 업무 모듈이 공통적으로 처리할 수 있겠다고 판단한 코드들은 common 파일로 분리하여 모듈 패턴으로 정리했습니다.

<br>

# 자기소개서 기반

## 왜 카카오페이에 지원했나요?
카카오 기술 블록, 카카오페이 블로그 글을 자주 읽습니다. 테크적인 부분, 가치관 등을 중점적으로 확인하죠. 제가 가장 사랑하는 단어가 많이 나왔습니다. 

카카오페이는 사용자들도 많고 연령대도 다양해서 기존의 방식으로는 사용 패턴을 예측하기 어려워요.

그래서 FE 개발 크루들은 전통적인 웹의 한계를 넘어

네이티브 앱에서의 편안함을 웹에서도 경험할 수 있도록 다양한 시도를 하고 있어요.


<br>

## 카카오페이의 문제는 뭐라고 생각하나요? 어떻게 개선해야됩니까?
너무 자주 바뀌는 UI 구성과 이해하기 어려운 결제방식 전개
다양한 기능을 늘리면서 간편결제라는 말이 무색할 만큼, UI와 구성이 복잡해지고 수시로 바뀐다. 카카오페이 내 카드 결제 시스템이 2종류고 은행계좌 연동을 통한 송금과 결제 잔고에 카카오머니라는 이름을 따로 붙였고 카카오페이 휴대폰 간편결제, 각종 마일리지 적립을 통합했다는 멤버십, 카카오페이 인증 등 서비스를 대폭 늘린 탓이다. 거기에 각 서비스들마다 이용약관 동의를 따로 받는다. 오프라인 결제 서비스를 시작하면서 또 버튼 배치를 수정했는데 언제까지 뜯어고칠지 알 수 없다. 사용자의 혼란을 불러일으키는 내부 시스템의 교통정리가 신속히 필요하고 결제와 송금만을 위한 직관적이고 단순한 UI 도입이 절실하다.

타 송금 서비스와 달리 충전은 만원 단위로만 이뤄진다. 별도로 설정할 수 있는 충전 설정은 충전 조건을 변경할 수 없으며 1만원 미만일 때 10만원씩만 가능하다. 물론 자동충전 사용 여부는 사용자가 설정할 수 있으며 충전 설정을 해놓지 않더라도 결제나 송금 시 잔액 확인 후 부족한 만큼 알아서 충전된다.

오프라인 결제를 하려면 잠금해제 후 매번 카카오톡을 실행해서 더보기 메뉴에 있는 결제 버튼을 찾아 들어가야 하는 단점이 있었는데 별도의 카카오페이 앱이 나오면서 그 부분은 조금 나아졌다. 하지만 그래도 앱을 열어야 하는 것 마찬가지, 그래서 빠르게 오프라인 결제를 하려면 위젯 사용이 필수적으로 권장되는데, 그럼에도 불구하고 안드로이드 카카오톡 내에는 위젯 만들기에 대해 안내하는 기능이나 문구가 전혀 없다. 구글 앱에선 날씨만 검색해도 날씨를 바로 볼 수 있는 바로가기를 홈화면에 만들 것인지 물어보는데...만들어놓고 써본 적도 없나...? 사용 편의성에 대해서 고민을 하지 않는 것인지 답답한 부분. 거기다 제공하는 위젯 크기가 4 x 2 밖에 없는 것도 아쉽다. 2019년 이후에 나올 스마트폰들엔 디스플레이 내장 지문인식이나 Face ID같은 얼굴인식 기술이 대중화될 가능성이 높고 이런 기술들과 결합되어 결제 단말기에 갖다대기만 하면 되는 애플 페이, 구글 페이, 저스터치 등과 비교하면 편의성이 떨어진다. 이런 부분을 조금이라도 보완하기 위해서는 송금, 스캔, 받기, 매장결제 등의 기능들 중 자주 쓰는 것만 앱처럼 홈화면에 꺼내둘 수 있도록 1 x 1, 2 x 1 등 다양한 크기의 위젯을 지원할 필요가 있다. 과거 스마트폰들의 홈 버튼 위치같은 곳에 결제 바로가기 위젯을 배치하는 것만으로도 결제코드를 꺼내는데 훨씬 동작을 줄일 수 있기 때문이다. 참고로 아직 카카오페이 앱에선 위젯을 지원하지 않으며 카카오톡에서 지원한다.

<br>

## 어떤 교육을 들었고 무엇이 제일 인상 깊었나요?
인프런, 패스트캠퍼스, 코드 스테이츠, 유튜브, 멀티캠퍼스, 코드잇... 많은 플랫폼의 강의를 들었으나 그 어떤 것도 마음에 들진 않았습니다. 제일 좋았던 것은 유튜브의 JSConf입니다. 시도해보지 못하거나 알지 못하는 영역에서 어떻게 개발하고 무슨 문제가 일어났으며 이를 극복하는 방법을 소개해주는 선배 개발자들의 발표는 너무 매력적이었고, 반드시 그렇게 되고 싶다 생각했습니다.

<br>

## 스터디는 어떻게 운영하고 무엇을 하고 있나요?
평일 저녁은 온라인 세션, 주말은 오프라인으로 진행합니다. 

<br>

## 카카오의 기술 블로그에서 무엇을 보고 가장 흥미로웠나요?
1차 https://tech.kakao.com/2021/04/08/welcome-new-krew3/
2차 https://tech.kakao.com/2020/12/03/frontend-growth-03/
3차 https://tech.kakao.com/2021/09/29/mocking-fe/


<br>

## 레거시 코드를 개선하면서 어떤 게 가장 기억나나요?


<br>

## 개발하고 싶은 웹 프레임워크는 어떤 건가요?
실시간으로 디버깅이 가능한 웹 프레임워크입니다. 브라우저를 사용하지 않고서 말이죠. 디버깅 포인트가 잡히면 자동으로 mock을 생성하고 이를 테스트할 수 있게 자동화할 수 있는 프레임워크를 개발하고 싶습니다. 이 때 주로 다루는 테스트 케이스로는 휴대용 기기로 국한하고 싶습니다.

<br>

## PL을 맡으셨다했는데 구체적으로 어떤 업무를 했나요?
IT 현업과의 회의 주도, 기술 고문을 했습니다.

<br>

## 개발 리더를 하면서 무엇을 담당했나요?
신입 개발자의 교육과 멘토링, 코드 리뷰와 프로젝트 중앙 통제소 역할을 했습니다.

<br>

# 사전과제 기반
## 구조를 왜 이렇게 짰나요?
flux 패턴을 구현하려고 했습니다.

https://bestalign.github.io/translation/cartoon-guide-to-flux/

<br>

## redux에 대해 설명해주세요.

<br>

## redux의 injection은 어떻게 되나요?

<br>

## 이벤트 핸들링을 이렇게 한 이유는 무엇인가요?

<br>

## 라우팅에 해시를 사용했는데, 왜 history API를 사용하지 않았나요?

<br>

## shadowDOM에 대해 설명해주세요.
Shadow DOM은 `<iframe>`과 같은 도구에 의존할 필요 없이, 웹 플랫폼에서 기본적으로 캡슐화와 구성요소화를 허용하기 위해 만들어졌습니다. 글로벌한 HTML 요소에 포함되지 않고 단일 요소로서의 스타일을 가질 수 있습니다.

또한 DOM에 부착되는 형태로, attachShadow(mode:open, close)를 사용하여 간단하게 선언할 수 있습니다. shadow host는 새로운 shadow DOM을 붙일 원본 DOM의 일반 HTML 요소를 사용합니다. Follow 버튼과 같은 구성요소의 경우, 페이지에 Javascript가 활성화되지 않았거나 shadow DOM이 지원되지 않을 경우 표시할 폴백 요소를 포함할 수 있습니다. 주로 상호 작용하는 특정 요소들은 shadow host가 될 수 없기 때문에, 단순히 <a> 요소를 shadow host로 사용할 수 없습니다.
호스트에 shadow DOM을 붙이기 위해, attachShadow() 메서드를 사용합니다. 이 코드는 shadow host의 자식 요소인 빈 shadow root를 생성합니다. <html> 요소가 DOM의 시작인 것처럼 shadow root는 shadow DOM의 시작점 역할을 합니다. 다음으로, 새로운 shadow tree를 만들기 위해 콘텐츠를 생성해야 합니다. shadow tree는 DOM tree와 비슷하지만 일반 DOM 대신 shadow DOM을 사용합니다.
follow 버튼을 생성하기 위해서는 이미 가지고 있는 폴백 링크와 거의 동일하지만 아이콘이 있는 새로운 <a> 요소가 필요합니다.
일반적인 방법과 동일하게 appendChild() 메서드를 사용하여 shadow DOM에 새로운 요소를 추가합니다.

어떤 면에서 shadow DOM은 DOM의 “lite” 버전입니다.
DOM과 같이 HTML 요소의 구조화된 표현이며, 페이지에 무엇을 표시할지 결정하고 요소의 수정을 가능하게 합니다. 하지만 DOM과 다르게 완전한 독립 문서를 기반으로 하지 않습니다.
이름에서 알 수 있듯이 shadow DOM은 항상 일반 DOM 내의 요소에 부착됩니다. DOM이 없으면 shadow DOM도 존재하지 않습니다.

<br>

## HTMLElement를 상속받는 GameTimer에 대해 설명해주세요.
타이머는 상태와는 상관 없이 해당 문제에서만 구동되어야했기에, 중앙 집중형 저장소를 통해 제어하면 안되었습니다. 그렇다고 전역으로 제어해도 안되었죠. 일관된 데이터흐름이 무너지니까요. 따라서 메인 컴포넌트의 하위로 커스텀엘리먼트를 선언한뒤, DOM 트리에서 완전히 분리된 고유의 요소와 스타일을 가진 DOM 트리로 구성했습니다.

<br>

## Wepack 설정을 이렇게 한 이유와 각 프로퍼티에 대한 설명 부탁드립니다.

<br>

## Babel 설정을 이렇게 한 이유와 각 프로퍼티에 대한 설명 부탁드립니다.

<br>

## package.json에 입력한 라이브러리가 각각 어떤 역할을 하는지 아시나요?

<br>

## jest에 왜 mock으로 테스트케이스를 짜지 않았나요?
https://ljlm0402.netlify.app/nodejs/jest.4/

<br>

## 버그에 대해서 알고 있나요? 어떻게 대처했나요?

<br>

## diff 알고리즘에 대해 설명해주세요.


<br>

## VirtualDOM을 어떻게 활용했나요?


<br>

## observable에 대해 설명해주세요.


<br>

## 이 store는 어떻게 구성했나요?

<br>

## 지금 코드에서 개선해야 하는 부분으 무엇이 있고, 어떻게 해야 할까요?

<br>

## 왜 컴포넌트를 저렇게 나누었나요?

<br>

## IE에서 작동되게 하려면 어떻게 해야 할까요?

<br>

## Vuex 형태로 구현할 수 있나요?

<br>

## Proxy 객체와 Object.defineProperty의 차이점은 무엇인가요?

<br>

## 왜 저런 형태의 pub/sub 패턴을 구현했나요?

<br>

## flux 패턴은 무엇인가요? 어떻게 구현했고 이 애플리케이션엔 어떻게 녹여 내었나요?

<br>

## 코드에 불필요한 중복은 어떻게 없앨 수 있을까요?

<br>

## html 태그의 역할은 무엇인가요?

<br>

## class 문법으로 작성한 이유는 무엇인가요? 함수형 컴포넌트로 해도 개발할 수 있나요?

<br>

## get, set을 어떻게 사용하면 효과적으로 쓸까요?

<br>

## 에러 처리에 대한 생각? 코드에는 에러를 처리한 부분이 명확하지 않은 것 같네요.

<br>

## 결과 화면에서의 뒤로가기 기능은 왜 이렇게 막혀있나요? 이에 따른 이슈는? 더 좋은 생각은 없을까요?

<br>

## Promise를 사용하지 않고 async/await를 사용한 이유는 무엇인가요?

<br>

## fetch API와 XhrHttpRequest의 차이점은 무엇인가요?

<br>

## 배포 경험
신용보증기금 PC-OFF API를 외주업체가 아닌 제가 독단 개발